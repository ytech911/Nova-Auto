# GUIDE COMPLET DES MODIFICATIONS POUR LA SAUVEGARDE DES CONVERSATIONS
# ET AUTRES AMÉLIORATIONS

Ce fichier contient toutes les modifications nécessaires pour ajouter la sauvegarde des conversations,
améliorer les fonctionnalités des paramètres, et corriger les bugs.

## 1. FICHIER: utils/storage.ts
### Action: CRÉER ce fichier s'il n'existe pas, ou REMPLACER complètement son contenu

```typescript
import AsyncStorage from '@react-native-async-storage/async-storage';

const CONVERSATIONS_KEY = 'osiris_conversations';
const CURRENT_CONVERSATION_KEY = 'osiris_current_conversation';
const USER_SETTINGS_KEY = 'osiris_user_settings';

export interface Message {
  id: string;
  text: string;
  isUser: boolean;
  attachments?: any[];
  timestamp: Date;
}

export interface Conversation {
  id: string;
  title: string;
  messages: Message[];
  lastUpdated: Date;
}

export interface UserSettings {
  theme: 'light' | 'dark' | 'system';
  accentColor: string;
  notifications: boolean;
  aiSuggestions: boolean;
  soundEffects: boolean;
  language: string;
}

// Save conversations to AsyncStorage
export const saveConversations = async (conversations: Conversation[]): Promise<void> => {
  try {
    const conversationsData = JSON.stringify(conversations);
    await AsyncStorage.setItem(CONVERSATIONS_KEY, conversationsData);
  } catch (error) {
    console.error('Error saving conversations:', error);
  }
};

// Load conversations from AsyncStorage
export const loadConversations = async (): Promise<Conversation[]> => {
  try {
    const conversationsData = await AsyncStorage.getItem(CONVERSATIONS_KEY);
    if (conversationsData) {
      const conversations = JSON.parse(conversationsData);
      // Convert date strings back to Date objects
      return conversations.map((conv: any) => ({
        ...conv,
        lastUpdated: new Date(conv.lastUpdated),
        messages: conv.messages.map((msg: any) => ({
          ...msg,
          timestamp: new Date(msg.timestamp)
        }))
      }));
    }
    return [];
  } catch (error) {
    console.error('Error loading conversations:', error);
    return [];
  }
};

// Save current conversation ID
export const saveCurrentConversationId = async (conversationId: string): Promise<void> => {
  try {
    await AsyncStorage.setItem(CURRENT_CONVERSATION_KEY, conversationId);
  } catch (error) {
    console.error('Error saving current conversation ID:', error);
  }
};

// Load current conversation ID
export const loadCurrentConversationId = async (): Promise<string | null> => {
  try {
    return await AsyncStorage.getItem(CURRENT_CONVERSATION_KEY);
  } catch (error) {
    console.error('Error loading current conversation ID:', error);
    return null;
  }
};

// Save user settings
export const saveUserSettings = async (settings: UserSettings): Promise<void> => {
  try {
    const settingsData = JSON.stringify(settings);
    await AsyncStorage.setItem(USER_SETTINGS_KEY, settingsData);
  } catch (error) {
    console.error('Error saving user settings:', error);
  }
};

// Load user settings
export const loadUserSettings = async (): Promise<UserSettings | null> => {
  try {
    const settingsData = await AsyncStorage.getItem(USER_SETTINGS_KEY);
    if (settingsData) {
      return JSON.parse(settingsData);
    }
    return null;
  } catch (error) {
    console.error('Error loading user settings:', error);
    return null;
  }
};

// Clear all stored data (for logout or reset)
export const clearStoredData = async (): Promise<void> => {
  try {
    await AsyncStorage.multiRemove([CONVERSATIONS_KEY, CURRENT_CONVERSATION_KEY, USER_SETTINGS_KEY]);
  } catch (error) {
    console.error('Error clearing stored data:', error);
  }
};

// Save a single conversation (for real-time updates)
export const saveConversation = async (conversation: Conversation, allConversations: Conversation[]): Promise<void> => {
  try {
    const updatedConversations = allConversations.map(conv => 
      conv.id === conversation.id ? conversation : conv
    );
    
    // If conversation doesn't exist, add it
    if (!allConversations.find(conv => conv.id === conversation.id)) {
      updatedConversations.push(conversation);
    }
    
    await saveConversations(updatedConversations);
  } catch (error) {
    console.error('Error saving conversation:', error);
  }
};

// Delete a conversation
export const deleteConversation = async (conversationId: string, allConversations: Conversation[]): Promise<Conversation[]> => {
  try {
    const updatedConversations = allConversations.filter(conv => conv.id !== conversationId);
    await saveConversations(updatedConversations);
    return updatedConversations;
  } catch (error) {
    console.error('Error deleting conversation:', error);
    return allConversations;
  }
};

// Delete multiple conversations
export const deleteConversations = async (conversationIds: string[], allConversations: Conversation[]): Promise<Conversation[]> => {
  try {
    const updatedConversations = allConversations.filter(conv => !conversationIds.includes(conv.id));
    await saveConversations(updatedConversations);
    return updatedConversations;
  } catch (error) {
    console.error('Error deleting conversations:', error);
    return allConversations;
  }
};
```

## 2. FICHIER: supabase/migrations/create_files_table.sql
### Action: CRÉER ce fichier dans le dossier supabase/migrations/

```sql
/*
  # Create files table for document management

  1. New Tables
    - `files`
      - `id` (uuid, primary key)
      - `name` (text, file name)
      - `size` (bigint, file size in bytes)
      - `type` (text, MIME type)
      - `url` (text, storage URL)
      - `subject` (text, subject category)
      - `user_id` (uuid, foreign key to auth.users)
      - `created_at` (timestamp)
      - `last_modified` (timestamp)

  2. Security
    - Enable RLS on `files` table
    - Add policy for users to manage their own files
*/

CREATE TABLE IF NOT EXISTS files (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  size bigint NOT NULL DEFAULT 0,
  type text NOT NULL DEFAULT 'application/octet-stream',
  url text NOT NULL,
  subject text NOT NULL DEFAULT 'General',
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at timestamptz DEFAULT now(),
  last_modified timestamptz DEFAULT now()
);

ALTER TABLE files ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage their own files"
  ON files
  FOR ALL
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Create storage bucket for files
INSERT INTO storage.buckets (id, name, public)
VALUES ('files', 'files', true)
ON CONFLICT (id) DO NOTHING;

-- Create storage policy
CREATE POLICY "Users can upload their own files"
  ON storage.objects
  FOR INSERT
  TO authenticated
  WITH CHECK (bucket_id = 'files' AND auth.uid()::text = (storage.foldername(name))[1]);

CREATE POLICY "Users can view their own files"
  ON storage.objects
  FOR SELECT
  TO authenticated
  USING (bucket_id = 'files' AND auth.uid()::text = (storage.foldername(name))[1]);

CREATE POLICY "Users can delete their own files"
  ON storage.objects
  FOR DELETE
  TO authenticated
  USING (bucket_id = 'files' AND auth.uid()::text = (storage.foldername(name))[1]);
```

## 3. FICHIER: app/(tabs)/ai.tsx
### Action: REMPLACER complètement le contenu existant

```typescript
import React, { useState, useRef, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TextInput, 
  TouchableOpacity, 
  FlatList, 
  KeyboardAvoidingView, 
  Platform,
  useColorScheme,
  ActivityIndicator,
  Animated,
  Dimensions,
  Alert
} from 'react-native';
import Colors from '@/constants/Colors';
import { Send, Mic, MicOff, Paperclip, X, FileText, Menu, Pencil, Trash2, Check } from 'lucide-react-native';
import * as DocumentPicker from 'expo-document-picker';
import * as Speech from 'expo-speech';
import { chatWithAI } from '@/utils/ai';
import { 
  saveConversations, 
  loadConversations, 
  saveCurrentConversationId, 
  loadCurrentConversationId,
  deleteConversations as deleteStoredConversations,
  saveConversation,
  type Conversation,
  type Message
} from '@/utils/storage';

const DRAWER_WIDTH = Dimensions.get('window').width * 0.8;

// Move styles outside the component to avoid initialization issues
const createStyles = (colors: any, isRecording: boolean) => StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.background,
  },
  header: {
    paddingTop: 60,
    paddingHorizontal: 16,
    paddingBottom: 16,
    backgroundColor: colors.primary,
    flexDirection: 'row',
    alignItems: 'center',
  },
  menuButton: {
    padding: 8,
    marginRight: 16,
  },
  headerTitle: {
    color: 'white',
    fontSize: 28,
    fontFamily: 'Inter-Bold',
    flex: 1,
  },
  headerSubtitle: {
    color: 'white',
    fontSize: 16,
    fontFamily: 'Inter-Regular',
    opacity: 0.9,
    marginTop: 4,
  },
  drawer: {
    position: 'absolute',
    left: 0,
    top: 0,
    bottom: 0,
    width: DRAWER_WIDTH,
    backgroundColor: colors.background,
    zIndex: 1000,
    elevation: 5,
    shadowColor: '#000',
    shadowOffset: { width: 2, height: 0 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  drawerHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    paddingTop: 60,
    backgroundColor: colors.primary,
  },
  drawerTitle: {
    color: 'white',
    fontSize: 20,
    fontFamily: 'Inter-Bold',
  },
  drawerActions: {
    flexDirection: 'row',
    gap: 16,
  },
  newConversationButton: {
    backgroundColor: colors.primary,
    margin: 16,
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
  },
  newConversationText: {
    color: 'white',
    fontFamily: 'Inter-Bold',
    fontSize: 16,
  },
  conversationList: {
    flex: 1,
  },
  conversationItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: colors.border,
  },
  conversationCheckbox: {
    width: 24,
    height: 24,
    borderRadius: 4,
    borderWidth: 2,
    borderColor: colors.primary,
    marginRight: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  conversationCheckboxSelected: {
    backgroundColor: colors.primary,
  },
  conversationInfo: {
    flex: 1,
  },
  conversationTitle: {
    fontSize: 16,
    fontFamily: 'Inter-Medium',
    color: colors.text,
    marginBottom: 4,
  },
  conversationTitleInput: {
    fontSize: 16,
    fontFamily: 'Inter-Medium',
    color: colors.text,
    borderWidth: 1,
    borderColor: colors.primary,
    borderRadius: 4,
    padding: 4,
    marginBottom: 4,
  },
  conversationDate: {
    fontSize: 12,
    fontFamily: 'Inter-Regular',
    color: colors.tabIconDefault,
  },
  deleteButton: {
    position: 'absolute',
    bottom: 16,
    left: 16,
    right: 16,
    backgroundColor: colors.error,
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'center',
  },
  deleteButtonText: {
    color: 'white',
    fontFamily: 'Inter-Bold',
    fontSize: 16,
    marginLeft: 8,
  },
  chatContainer: {
    flex: 1,
    paddingTop: 16,
  },
  messageContainer: {
    paddingHorizontal: 16,
    marginBottom: 12,
    flexDirection: 'row',
    justifyContent: 'flex-start',
  },
  userMessageContainer: {
    justifyContent: 'flex-end',
  },
  messageBubble: {
    maxWidth: '80%',
    backgroundColor: colors.cardBackground,
    borderRadius: 16,
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderTopLeftRadius: 4,
  },
  userMessageBubble: {
    backgroundColor: colors.primary,
    borderTopLeftRadius: 16,
    borderTopRightRadius: 4,
  },
  messageText: {
    fontFamily: 'Inter-Regular',
    fontSize: 16,
    color: colors.text,
  },
  userMessageText: {
    color: 'white',
  },
  attachmentsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    padding: 8,
    gap: 8,
  },
  attachmentPreview: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: `${colors.primary}10`,
    borderRadius: 8,
    padding: 8,
    marginRight: 8,
  },
  attachmentName: {
    marginLeft: 8,
    marginRight: 24,
    fontSize: 14,
    color: colors.text,
    maxWidth: 120,
  },
  removeAttachment: {
    position: 'absolute',
    right: 4,
    top: 4,
  },
  inputContainer: {
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderTopWidth: 1,
    borderTopColor: colors.border,
    backgroundColor: colors.background,
  },
  inputWrapper: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  input: {
    flex: 1,
    backgroundColor: colors.cardBackground,
    borderRadius: 24,
    paddingHorizontal: 16,
    paddingVertical: 10,
    fontFamily: 'Inter-Regular',
    fontSize: 16,
    color: colors.text,
    marginRight: 8,
  },
  attachButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: colors.secondary,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 8,
  },
  sendButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: colors.primary,
    justifyContent: 'center',
    alignItems: 'center',
  },
  micButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: isRecording ? colors.error : colors.secondary,
    justifyContent: 'center',
    alignItems: 'center',
  },
  recordingTimer: {
    position: 'absolute',
    top: -24,
    right: 0,
    backgroundColor: colors.error,
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 4,
  },
  recordingTimerText: {
    color: 'white',
    fontSize: 12,
    fontFamily: 'Inter-Medium',
  },
  loadingContainer: {
    padding: 16,
    alignItems: 'center',
  },
  messageAttachment: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: `${colors.primary}10`,
    borderRadius: 8,
    padding: 8,
    marginTop: 8,
  },
  messageAttachmentName: {
    marginLeft: 8,
    fontSize: 14,
    color: colors.text,
  },
  overlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    zIndex: 999,
  },
  renameButton: {
    padding: 8,
  },
});

export default function AiChatScreen() {
  const colorScheme = useColorScheme();
  const colors = Colors[colorScheme ?? 'light'];
  const [message, setMessage] = useState('');
  const [isRecording, setIsRecording] = useState(false);
  const [recordingTimer, setRecordingTimer] = useState(0);
  const [isLoading, setIsLoading] = useState(false);
  const [attachments, setAttachments] = useState([]);
  const [isDrawerOpen, setIsDrawerOpen] = useState(false);
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [currentConversation, setCurrentConversation] = useState<Conversation | null>(null);
  const [selectedConversations, setSelectedConversations] = useState<string[]>([]);
  const [isEditMode, setIsEditMode] = useState(false);
  const [editingConversationId, setEditingConversationId] = useState<string | null>(null);
  const [newTitle, setNewTitle] = useState('');
  const [isInitializing, setIsInitializing] = useState(true);
  
  const flatListRef = useRef(null);
  const inputRef = useRef(null);
  const drawerAnimation = useRef(new Animated.Value(-DRAWER_WIDTH)).current;
  const timerInterval = useRef<NodeJS.Timeout | null>(null);

  // Create styles with current state
  const styles = createStyles(colors, isRecording);

  // Load conversations and current conversation on app start
  useEffect(() => {
    initializeConversations();
  }, []);

  // Save conversations whenever they change
  useEffect(() => {
    if (!isInitializing && conversations.length > 0) {
      saveConversations(conversations);
    }
  }, [conversations, isInitializing]);

  // Save current conversation ID whenever it changes
  useEffect(() => {
    if (!isInitializing && currentConversation) {
      saveCurrentConversationId(currentConversation.id);
    }
  }, [currentConversation, isInitializing]);

  const initializeConversations = async () => {
    try {
      setIsInitializing(true);
      
      // Load saved conversations
      const savedConversations = await loadConversations();
      
      if (savedConversations.length > 0) {
        setConversations(savedConversations);
        
        // Load the last active conversation
        const savedCurrentId = await loadCurrentConversationId();
        const savedCurrent = savedConversations.find(conv => conv.id === savedCurrentId);
        
        if (savedCurrent) {
          setCurrentConversation(savedCurrent);
        } else {
          // If saved current conversation doesn't exist, use the first one
          setCurrentConversation(savedConversations[0]);
        }
      } else {
        // Create initial conversation if none exists
        const initialConversation: Conversation = {
          id: Date.now().toString(),
          title: 'Nouvelle conversation',
          messages: [{
            id: '1',
            text: 'Bonjour! Je suis Osiris, votre assistant intelligent. Comment puis-je vous aider aujourd\'hui?',
            isUser: false,
            timestamp: new Date()
          }],
          lastUpdated: new Date()
        };
        
        const initialConversations = [initialConversation];
        setConversations(initialConversations);
        setCurrentConversation(initialConversation);
        
        // Save initial state
        await saveConversations(initialConversations);
        await saveCurrentConversationId(initialConversation.id);
      }
    } catch (error) {
      console.error('Error initializing conversations:', error);
      
      // Fallback: create a new conversation
      const fallbackConversation: Conversation = {
        id: Date.now().toString(),
        title: 'Nouvelle conversation',
        messages: [{
          id: '1',
          text: 'Bonjour! Je suis Osiris, votre assistant intelligent. Comment puis-je vous aider aujourd\'hui?',
          isUser: false,
          timestamp: new Date()
        }],
        lastUpdated: new Date()
      };
      
      setConversations([fallbackConversation]);
      setCurrentConversation(fallbackConversation);
    } finally {
      setIsInitializing(false);
    }
  };

  useEffect(() => {
    if (isRecording) {
      timerInterval.current = setInterval(() => {
        setRecordingTimer(prev => prev + 1);
      }, 1000);
    } else {
      if (timerInterval.current) {
        clearInterval(timerInterval.current);
        setRecordingTimer(0);
      }
    }
    return () => {
      if (timerInterval.current) {
        clearInterval(timerInterval.current);
      }
    };
  }, [isRecording]);

  const toggleDrawer = () => {
    const toValue = isDrawerOpen ? -DRAWER_WIDTH : 0;
    Animated.spring(drawerAnimation, {
      toValue,
      useNativeDriver: true,
      tension: 65,
      friction: 11
    }).start();
    setIsDrawerOpen(!isDrawerOpen);
  };

  const selectConversation = async (conversation: Conversation) => {
    if (isEditMode) {
      const isSelected = selectedConversations.includes(conversation.id);
      if (isSelected) {
        setSelectedConversations(prev => prev.filter(id => id !== conversation.id));
      } else {
        setSelectedConversations(prev => [...prev, conversation.id]);
      }
    } else {
      setCurrentConversation(conversation);
      await saveCurrentConversationId(conversation.id);
      toggleDrawer();
    }
  };

  const deleteSelectedConversations = async () => {
    try {
      const updatedConversations = await deleteStoredConversations(selectedConversations, conversations);
      setConversations(updatedConversations);
      setSelectedConversations([]);
      setIsEditMode(false);
      
      // If current conversation is deleted, switch to the first available one
      if (currentConversation && selectedConversations.includes(currentConversation.id)) {
        if (updatedConversations.length > 0) {
          const newCurrent = updatedConversations[0];
          setCurrentConversation(newCurrent);
          await saveCurrentConversationId(newCurrent.id);
        } else {
          // Create a new conversation if all were deleted
          const newConversation: Conversation = {
            id: Date.now().toString(),
            title: 'Nouvelle conversation',
            messages: [{
              id: '1',
              text: 'Bonjour! Je suis Osiris, votre assistant intelligent. Comment puis-je vous aider aujourd\'hui?',
              isUser: false,
              timestamp: new Date()
            }],
            lastUpdated: new Date()
          };
          
          setConversations([newConversation]);
          setCurrentConversation(newConversation);
          await saveConversations([newConversation]);
          await saveCurrentConversationId(newConversation.id);
        }
      }
    } catch (error) {
      console.error('Error deleting conversations:', error);
      Alert.alert('Erreur', 'Impossible de supprimer les conversations');
    }
  };

  const startNewConversation = async () => {
    const newConversation: Conversation = {
      id: Date.now().toString(),
      title: 'Nouvelle conversation',
      messages: [{
        id: '1',
        text: 'Bonjour! Je suis Osiris, votre assistant intelligent. Comment puis-je vous aider aujourd\'hui?',
        isUser: false,
        timestamp: new Date()
      }],
      lastUpdated: new Date()
    };
    
    const updatedConversations = [...conversations, newConversation];
    setConversations(updatedConversations);
    setCurrentConversation(newConversation);
    
    // Save to storage
    await saveConversations(updatedConversations);
    await saveCurrentConversationId(newConversation.id);
    
    toggleDrawer();
  };

  const startRenamingConversation = (conversation: Conversation) => {
    setEditingConversationId(conversation.id);
    setNewTitle(conversation.title);
  };

  const handleRenameConversation = async () => {
    if (!editingConversationId || !newTitle.trim()) return;

    // Check if the new title already exists
    const titleExists = conversations.some(
      conv => conv.id !== editingConversationId && conv.title.toLowerCase() === newTitle.trim().toLowerCase()
    );

    if (titleExists) {
      Alert.alert(
        "Titre déjà utilisé",
        "Une conversation avec ce titre existe déjà. Veuillez choisir un titre différent."
      );
      return;
    }

    const updatedConversations = conversations.map(conv =>
      conv.id === editingConversationId
        ? { ...conv, title: newTitle.trim(), lastUpdated: new Date() }
        : conv
    );
    
    setConversations(updatedConversations);
    
    // Update current conversation if it's the one being renamed
    if (currentConversation && currentConversation.id === editingConversationId) {
      setCurrentConversation({
        ...currentConversation,
        title: newTitle.trim(),
        lastUpdated: new Date()
      });
    }
    
    // Save to storage
    await saveConversations(updatedConversations);
    
    setEditingConversationId(null);
    setNewTitle('');
  };

  const sendMessage = async () => {
    if (message.trim() === '' && attachments.length === 0) return;
    if (!currentConversation) return;
    
    const newUserMessage: Message = {
      id: Date.now().toString(),
      text: message,
      isUser: true,
      attachments: [...attachments],
      timestamp: new Date()
    };
    
    // Update current conversation
    const updatedConversation: Conversation = {
      ...currentConversation,
      messages: [...currentConversation.messages, newUserMessage],
      lastUpdated: new Date()
    };
    
    // Update state
    setConversations(prev =>
      prev.map(conv =>
        conv.id === currentConversation.id ? updatedConversation : conv
      )
    );
    setCurrentConversation(updatedConversation);
    
    // Save to storage
    await saveConversation(updatedConversation, conversations);
    
    setMessage('');
    setAttachments([]);
    setIsLoading(true);
    
    try {
      const aiResponse = await chatWithAI(message, attachments);
      const newAiMessage: Message = {
        id: (Date.now() + 1).toString(),
        text: aiResponse,
        isUser: false,
        timestamp: new Date()
      };
      
      const finalConversation: Conversation = {
        ...updatedConversation,
        messages: [...updatedConversation.messages, newAiMessage],
        lastUpdated: new Date()
      };
      
      // Update state
      setConversations(prev =>
        prev.map(conv =>
          conv.id === currentConversation.id ? finalConversation : conv
        )
      );
      setCurrentConversation(finalConversation);
      
      // Save to storage
      await saveConversation(finalConversation, conversations);
      
      // Update conversation title based on context if it's the first user message
      if (updatedConversation.messages.length === 2) {
        const title = message.length > 30 
          ? message.substring(0, 30) + '...'
          : message;
        
        // Check if title already exists
        let newTitle = title;
        let counter = 1;
        while (conversations.some(conv => 
          conv.id !== currentConversation.id && 
          conv.title.toLowerCase() === newTitle.toLowerCase()
        )) {
          newTitle = `${title} (${counter})`;
          counter++;
        }
        
        const finalConversationWithTitle: Conversation = {
          ...finalConversation,
          title: newTitle
        };
        
        // Update state
        setConversations(prev =>
          prev.map(conv =>
            conv.id === currentConversation.id ? finalConversationWithTitle : conv
          )
        );
        setCurrentConversation(finalConversationWithTitle);
        
        // Save to storage
        await saveConversation(finalConversationWithTitle, conversations);
      }
    } catch (error) {
      console.error('Error getting AI response:', error);
      const errorMessage: Message = {
        id: (Date.now() + 1).toString(),
        text: error instanceof Error ? error.message : "Désolé, je ne peux pas répondre pour le moment. Veuillez réessayer plus tard.",
        isUser: false,
        timestamp: new Date()
      };
      
      const errorConversation: Conversation = {
        ...updatedConversation,
        messages: [...updatedConversation.messages, errorMessage],
        lastUpdated: new Date()
      };
      
      // Update state
      setConversations(prev =>
        prev.map(conv =>
          conv.id === currentConversation.id ? errorConversation : conv
        )
      );
      setCurrentConversation(errorConversation);
      
      // Save to storage
      await saveConversation(errorConversation, conversations);
    } finally {
      setIsLoading(false);
      if (flatListRef.current) {
        flatListRef.current.scrollToEnd({ animated: true });
      }
    }
  };

  const handleAttachment = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: '*/*',
        multiple: true,
      });

      if (!result.canceled) {
        setAttachments(prev => [...prev, ...result.assets]);
      }
    } catch (error) {
      console.error('Error picking document:', error);
    }
  };

  const removeAttachment = (index: number) => {
    setAttachments(prev => prev.filter((_, i) => i !== index));
  };

  const toggleRecording = async () => {
    setIsRecording(!isRecording);
    if (isRecording) {
      setTimeout(() => {
        const transcribedText = "Rappelle-moi d'étudier pour l'examen de mathématiques demain à 15h";
        setMessage(transcribedText);
      }, 1000);
    } else {
      if (Platform.OS !== 'web') {
        Speech.speak('Enregistrement démarré');
      }
    }
  };

  const formatTimer = (seconds: number) => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
  };

  // Show loading screen while initializing
  if (isInitializing) {
    return (
      <View style={[styles.container, { justifyContent: 'center', alignItems: 'center' }]}>
        <ActivityIndicator size="large" color={colors.primary} />
        <Text style={{ color: colors.text, marginTop: 16, fontFamily: 'Inter-Regular' }}>
          Chargement des conversations...
        </Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <TouchableOpacity style={styles.menuButton} onPress={toggleDrawer}>
          <Menu size={24} color="white" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Osiris AI</Text>
      </View>

      {/* Drawer */}
      <Animated.View 
        style={[
          styles.drawer,
          {
            transform: [{ translateX: drawerAnimation }]
          }
        ]}
      >
        <View style={styles.drawerHeader}>
          <Text style={styles.drawerTitle}>Conversations</Text>
          <View style={styles.drawerActions}>
            <TouchableOpacity onPress={() => setIsEditMode(!isEditMode)}>
              <Pencil size={24} color="white" />
            </TouchableOpacity>
            <TouchableOpacity onPress={toggleDrawer}>
              <X size={24} color="white" />
            </TouchableOpacity>
          </View>
        </View>

        <TouchableOpacity 
          style={styles.newConversationButton}
          onPress={startNewConversation}
        >
          <Text style={styles.newConversationText}>Nouvelle conversation</Text>
        </TouchableOpacity>

        <FlatList
          style={styles.conversationList}
          data={conversations}
          keyExtractor={(item) => item.id}
          renderItem={({ item }) => (
            <TouchableOpacity 
              style={styles.conversationItem}
              onPress={() => selectConversation(item)}
            >
              {isEditMode && (
                <View style={[
                  styles.conversationCheckbox,
                  selectedConversations.includes(item.id) && styles.conversationCheckboxSelected
                ]}>
                  {selectedConversations.includes(item.id) && (
                    <Check size={16} color="white" />
                  )}
                </View>
              )}
              <View style={styles.conversationInfo}>
                {editingConversationId === item.id ? (
                  <TextInput
                    style={styles.conversationTitleInput}
                    value={newTitle}
                    onChangeText={setNewTitle}
                    onBlur={handleRenameConversation}
                    onSubmitEditing={handleRenameConversation}
                    autoFocus
                  />
                ) : (
                  <>
                    <Text style={styles.conversationTitle}>{item.title}</Text>
                    <Text style={styles.conversationDate}>
                      {new Date(item.lastUpdated).toLocaleDateString()}
                    </Text>
                  </>
                )}
              </View>
              {!isEditMode && (
                <TouchableOpacity
                  style={styles.renameButton}
                  onPress={() => startRenamingConversation(item)}
                >
                  <Pencil size={20} color={colors.text} />
                </TouchableOpacity>
              )}
            </TouchableOpacity>
          )}
        />

        {isEditMode && selectedConversations.length > 0 && (
          <TouchableOpacity 
            style={styles.deleteButton}
            onPress={deleteSelectedConversations}
          >
            <Trash2 size={20} color="white" />
            <Text style={styles.deleteButtonText}>
              Supprimer ({selectedConversations.length})
            </Text>
          </TouchableOpacity>
        )}
      </Animated.View>

      {/* Chat Content */}
      <View style={styles.chatContainer}>
        <FlatList
          ref={flatListRef}
          data={currentConversation?.messages || []}
          keyExtractor={(item) => item.id}
          renderItem={({ item }) => (
            <View style={[
              styles.messageContainer,
              item.isUser && styles.userMessageContainer
            ]}>
              <View style={[
                styles.messageBubble,
                item.isUser && styles.userMessageBubble
              ]}>
                <Text style={[
                  styles.messageText,
                  item.isUser && styles.userMessageText
                ]}>
                  {item.text}
                </Text>
                {item.attachments && Array.isArray(item.attachments) && item.attachments.map((attachment, index) => (
                  <View key={index} style={styles.messageAttachment}>
                    <FileText size={20} color={colors.text} />
                    <Text style={styles.messageAttachmentName}>
                      {attachment.name}
                    </Text>
                  </View>
                ))}
              </View>
            </View>
          )}
          onContentSizeChange={() => flatListRef.current?.scrollToEnd({ animated: true })}
          onLayout={() => flatListRef.current?.scrollToEnd({ animated: true })}
        />

        {isLoading && (
          <View style={styles.loadingContainer}>
            <ActivityIndicator color={colors.primary} />
          </View>
        )}
      </View>

      {/* Input Area */}
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 90 : 0}
      >
        <View style={styles.inputContainer}>
          {attachments.length > 0 && (
            <View style={styles.attachmentsContainer}>
              {attachments.map((file, index) => (
                <View key={index} style={styles.attachmentPreview}>
                  <FileText size={20} color={colors.text} />
                  <Text style={styles.attachmentName} numberOfLines={1}>
                    {file.name}
                  </Text>
                  <TouchableOpacity
                    style={styles.removeAttachment}
                    onPress={() => removeAttachment(index)}
                  >
                    <X size={16} color={colors.text} />
                  </TouchableOpacity>
                </View>
              ))}
            </View>
          )}
          
          <View style={styles.inputWrapper}>
            <TouchableOpacity style={styles.attachButton} onPress={handleAttachment}>
              <Paperclip size={20} color="white" />
            </TouchableOpacity>
            
            <TextInput
              ref={inputRef}
              style={styles.input}
              placeholder="Posez votre question à Osiris..."
              placeholderTextColor={colors.tabIconDefault}
              value={message}
              onChangeText={setMessage}
              onSubmitEditing={sendMessage}
              multiline
              blurOnSubmit={false}
            />
            
            {message.trim() !== '' || attachments.length > 0 ? (
              <TouchableOpacity
                style={styles.sendButton}
                onPress={sendMessage}
                disabled={isLoading}
              >
                <Send size={20} color="white" />
              </TouchableOpacity>
            ) : (
              <TouchableOpacity
                style={styles.micButton}
                onPress={toggleRecording}
              >
                {isRecording && (
                  <View style={styles.recordingTimer}>
                    <Text style={styles.recordingTimerText}>
                      {formatTimer(recordingTimer)}
                    </Text>
                  </View>
                )}
                {isRecording ? (
                  <MicOff size={20} color="white" />
                ) : (
                  <Mic size={20} color="white" />
                )}
              </TouchableOpacity>
            )}
          </View>
        </View>
      </KeyboardAvoidingView>

      {/* Overlay when drawer is open */}
      {isDrawerOpen && (
        <TouchableOpacity
          style={styles.overlay}
          activeOpacity={1}
          onPress={toggleDrawer}
        />
      )}
    </View>
  );
}
```

## 4. FICHIER: app/(tabs)/settings.tsx
### Action: REMPLACER complètement le contenu existant

```typescript
import React, { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  ScrollView, 
  Switch, 
  TouchableOpacity, 
  useColorScheme,
  Alert,
  Platform
} from 'react-native';
import Colors from '@/constants/Colors';
import { User, Moon, Bell, Palette, LogOut, ChevronRight, CircleHelp as HelpCircle, Languages } from 'lucide-react-native';
import { Link, router } from 'expo-router';
import { saveUserSettings, loadUserSettings, clearStoredData, type UserSettings } from '@/utils/storage';

export default function SettingsScreen() {
  const systemColorScheme = useColorScheme();
  const [userTheme, setUserTheme] = useState<'light' | 'dark' | 'system'>('system');
  const [accentColor, setAccentColor] = useState('#2E7D32');
  const [notifications, setNotifications] = useState(true);
  const [aiSuggestions, setAiSuggestions] = useState(true);
  const [soundEffects, setSoundEffects] = useState(true);
  const [language, setLanguage] = useState('fr');
  const [isLoading, setIsLoading] = useState(true);

  // Determine effective color scheme
  const effectiveColorScheme = userTheme === 'system' ? systemColorScheme : userTheme;
  const colors = Colors[effectiveColorScheme ?? 'light'];

  // Load settings on component mount
  useEffect(() => {
    loadSettings();
  }, []);

  // Save settings whenever they change
  useEffect(() => {
    if (!isLoading) {
      saveSettings();
    }
  }, [userTheme, accentColor, notifications, aiSuggestions, soundEffects, language, isLoading]);

  const loadSettings = async () => {
    try {
      const savedSettings = await loadUserSettings();
      if (savedSettings) {
        setUserTheme(savedSettings.theme);
        setAccentColor(savedSettings.accentColor);
        setNotifications(savedSettings.notifications);
        setAiSuggestions(savedSettings.aiSuggestions);
        setSoundEffects(savedSettings.soundEffects);
        setLanguage(savedSettings.language);
      }
    } catch (error) {
      console.error('Error loading settings:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const saveSettings = async () => {
    try {
      const settings: UserSettings = {
        theme: userTheme,
        accentColor,
        notifications,
        aiSuggestions,
        soundEffects,
        language
      };
      await saveUserSettings(settings);
    } catch (error) {
      console.error('Error saving settings:', error);
    }
  };

  const handleLogout = () => {
    Alert.alert(
      "Confirmer la déconnexion",
      "Êtes-vous sûr de vouloir vous déconnecter ? Toutes les données locales seront supprimées.",
      [
        {
          text: "Annuler",
          style: "cancel"
        },
        {
          text: "Déconnexion",
          onPress: async () => {
            try {
              await clearStoredData();
              router.replace('/auth/login');
            } catch (error) {
              console.error('Error during logout:', error);
              Alert.alert('Erreur', 'Impossible de se déconnecter');
            }
          },
          style: "destructive"
        }
      ]
    );
  };

  const handleThemeChange = (theme: 'light' | 'dark' | 'system') => {
    setUserTheme(theme);
    
    // Show feedback to user
    if (Platform.OS === 'web') {
      // For web, we can show a simple alert
      const themeNames = {
        light: 'Clair',
        dark: 'Sombre',
        system: 'Système'
      };
      console.log(`Thème changé vers: ${themeNames[theme]}`);
    }
  };

  const handleColorChange = (color: string) => {
    setAccentColor(color);
    
    // Show feedback to user
    if (Platform.OS === 'web') {
      console.log(`Couleur d'accent changée vers: ${color}`);
    }
  };

  const handleNotificationToggle = (value: boolean) => {
    setNotifications(value);
    
    if (Platform.OS !== 'web') {
      // On mobile, you could request notification permissions here
      console.log(`Notifications ${value ? 'activées' : 'désactivées'}`);
    }
  };

  const colorOptions = [
    { id: 'green', color: '#2E7D32', name: 'Vert' },
    { id: 'blue', color: '#2196F3', name: 'Bleu' },
    { id: 'purple', color: '#6200EA', name: 'Violet' },
    { id: 'teal', color: '#00BFA5', name: 'Sarcelle' },
    { id: 'orange', color: '#FF5722', name: 'Orange' },
    { id: 'pink', color: '#E91E63', name: 'Rose' },
  ];

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: colors.background,
    },
    header: {
      paddingTop: 60,
      paddingHorizontal: 16,
      paddingBottom: 16,
      backgroundColor: colors.primary,
    },
    headerTitle: {
      color: 'white',
      fontSize: 28,
      fontFamily: 'Inter-Bold',
    },
    headerSubtitle: {
      color: 'white',
      fontSize: 16,
      fontFamily: 'Inter-Regular',
      opacity: 0.9,
      marginTop: 4,
    },
    content: {
      flex: 1,
      paddingTop: 16,
    },
    sectionHeader: {
      paddingHorizontal: 16,
      paddingVertical: 8,
      backgroundColor: colors.cardBackground,
      marginBottom: 8,
    },
    sectionHeaderText: {
      fontFamily: 'Inter-Bold',
      fontSize: 16,
      color: colors.text,
      textTransform: 'uppercase',
      opacity: 0.7,
    },
    settingItem: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: 16,
      paddingHorizontal: 16,
      borderBottomWidth: 1,
      borderBottomColor: colors.border,
    },
    settingIconContainer: {
      width: 40,
      height: 40,
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: 8,
      backgroundColor: `${colors.primary}20`,
      marginRight: 16,
    },
    settingInfo: {
      flex: 1,
    },
    settingTitle: {
      fontFamily: 'Inter-Medium',
      fontSize: 16,
      color: colors.text,
    },
    settingDescription: {
      fontFamily: 'Inter-Regular',
      fontSize: 12,
      color: colors.tabIconDefault,
      marginTop: 4,
    },
    themeButtonsContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      marginTop: 16,
      marginBottom: 8,
      paddingHorizontal: 16,
    },
    themeButton: {
      paddingVertical: 8,
      paddingHorizontal: 16,
      borderRadius: 16,
      backgroundColor: colors.cardBackground,
      borderWidth: 1,
      borderColor: colors.border,
    },
    themeButtonSelected: {
      borderColor: colors.primary,
      backgroundColor: `${colors.primary}20`,
    },
    themeButtonText: {
      fontFamily: 'Inter-Medium',
      fontSize: 14,
      color: colors.text,
    },
    themeButtonTextSelected: {
      color: colors.primary,
    },
    colorOptionsContainer: {
      flexDirection: 'row',
      justifyContent: 'space-around',
      marginTop: 16,
      marginBottom: 8,
      paddingHorizontal: 16,
    },
    colorOption: {
      width: 40,
      height: 40,
      borderRadius: 20,
      justifyContent: 'center',
      alignItems: 'center',
      borderWidth: 2,
      borderColor: 'transparent',
    },
    colorOptionSelected: {
      borderColor: colors.text,
    },
    colorDot: {
      width: 30,
      height: 30,
      borderRadius: 15,
    },
    versionContainer: {
      padding: 16,
      alignItems: 'center',
    },
    versionText: {
      fontFamily: 'Inter-Regular',
      fontSize: 14,
      color: colors.tabIconDefault,
    },
    logoutButton: {
      marginHorizontal: 16,
      marginTop: 24,
      marginBottom: 32,
      backgroundColor: `${colors.error}20`,
      padding: 16,
      borderRadius: 8,
      alignItems: 'center',
    },
    logoutButtonText: {
      fontFamily: 'Inter-Medium',
      fontSize: 16,
      color: colors.error,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      fontFamily: 'Inter-Regular',
      fontSize: 16,
      color: colors.text,
      marginTop: 16,
    },
  });

  if (isLoading) {
    return (
      <View style={styles.container}>
        <View style={styles.header}>
          <Text style={styles.headerTitle}>Paramètres</Text>
          <Text style={styles.headerSubtitle}>Personnalisez votre expérience</Text>
        </View>
        <View style={styles.loadingContainer}>
          <Text style={styles.loadingText}>Chargement des paramètres...</Text>
        </View>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.headerTitle}>Paramètres</Text>
        <Text style={styles.headerSubtitle}>Personnalisez votre expérience</Text>
      </View>

      <ScrollView style={styles.content}>
        <View style={styles.sectionHeader}>
          <Text style={styles.sectionHeaderText}>Compte</Text>
        </View>
        
        <TouchableOpacity style={styles.settingItem}>
          <View style={styles.settingIconContainer}>
            <User size={20} color={colors.primary} />
          </View>
          <View style={styles.settingInfo}>
            <Text style={styles.settingTitle}>Profil</Text>
            <Text style={styles.settingDescription}>Modifier vos informations personnelles</Text>
          </View>
          <ChevronRight size={20} color={colors.tabIconDefault} />
        </TouchableOpacity>

        <View style={styles.sectionHeader}>
          <Text style={styles.sectionHeaderText}>Apparence</Text>
        </View>
        
        <View style={styles.settingItem}>
          <View style={styles.settingIconContainer}>
            <Moon size={20} color={colors.primary} />
          </View>
          <View style={styles.settingInfo}>
            <Text style={styles.settingTitle}>Thème</Text>
            <Text style={styles.settingDescription}>Choisissez votre thème préféré</Text>
          </View>
        </View>
        
        <View style={styles.themeButtonsContainer}>
          <TouchableOpacity 
            style={[
              styles.themeButton,
              userTheme === 'light' && styles.themeButtonSelected
            ]}
            onPress={() => handleThemeChange('light')}
          >
            <Text style={[
              styles.themeButtonText,
              userTheme === 'light' && styles.themeButtonTextSelected
            ]}>
              Clair
            </Text>
          </TouchableOpacity>
          <TouchableOpacity 
            style={[
              styles.themeButton,
              userTheme === 'dark' && styles.themeButtonSelected
            ]}
            onPress={() => handleThemeChange('dark')}
          >
            <Text style={[
              styles.themeButtonText,
              userTheme === 'dark' && styles.themeButtonTextSelected
            ]}>
              Sombre
            </Text>
          </TouchableOpacity>
          <TouchableOpacity 
            style={[
              styles.themeButton,
              userTheme === 'system' && styles.themeButtonSelected
            ]}
            onPress={() => handleThemeChange('system')}
          >
            <Text style={[
              styles.themeButtonText,
              userTheme === 'system' && styles.themeButtonTextSelected
            ]}>
              Système
            </Text>
          </TouchableOpacity>
        </View>

        <View style={styles.settingItem}>
          <View style={styles.settingIconContainer}>
            <Palette size={20} color={colors.primary} />
          </View>
          <View style={styles.settingInfo}>
            <Text style={styles.settingTitle}>Couleur d'accent</Text>
            <Text style={styles.settingDescription}>Choisissez la couleur d'accent de l'app</Text>
          </View>
        </View>

        <View style={styles.colorOptionsContainer}>
          {colorOptions.map((option) => (
            <TouchableOpacity 
              key={option.id}
              style={[
                styles.colorOption,
                accentColor === option.color && styles.colorOptionSelected
              ]}
              onPress={() => handleColorChange(option.color)}
            >
              <View 
                style={[
                  styles.colorDot,
                  { backgroundColor: option.color }
                ]} 
              />
            </TouchableOpacity>
          ))}
        </View>

        <View style={styles.sectionHeader}>
          <Text style={styles.sectionHeaderText}>Notifications</Text>
        </View>
        
        <View style={styles.settingItem}>
          <View style={styles.settingIconContainer}>
            <Bell size={20} color={colors.primary} />
          </View>
          <View style={styles.settingInfo}>
            <Text style={styles.settingTitle}>Notifications Push</Text>
            <Text style={styles.settingDescription}>Recevoir des alertes pour les événements importants</Text>
          </View>
          <Switch
            value={notifications}
            onValueChange={handleNotificationToggle}
            trackColor={{ false: colors.border, true: `${colors.primary}80` }}
            thumbColor={notifications ? colors.primary : '#f4f3f4'}
          />
        </View>

        <View style={styles.sectionHeader}>
          <Text style={styles.sectionHeaderText}>Osiris AI</Text>
        </View>
        
        <View style={styles.settingItem}>
          <View style={styles.settingIconContainer}>
            <Languages size={20} color={colors.primary} />
          </View>
          <View style={styles.settingInfo}>
            <Text style={styles.settingTitle}>Suggestions IA</Text>
            <Text style={styles.settingDescription}>Obtenir des recommandations intelligentes d'Osiris</Text>
          </View>
          <Switch
            value={aiSuggestions}
            onValueChange={setAiSuggestions}
            trackColor={{ false: colors.border, true: `${colors.primary}80` }}
            thumbColor={aiSuggestions ? colors.primary : '#f4f3f4'}
          />
        </View>

        <View style={styles.settingItem}>
          <View style={styles.settingIconContainer}>
            <HelpCircle size={20} color={colors.primary} />
          </View>
          <View style={styles.settingInfo}>
            <Text style={styles.settingTitle}>Effets sonores</Text>
            <Text style={styles.settingDescription}>Activer le son pour les réponses IA</Text>
          </View>
          <Switch
            value={soundEffects}
            onValueChange={setSoundEffects}
            trackColor={{ false: colors.border, true: `${colors.primary}80` }}
            thumbColor={soundEffects ? colors.primary : '#f4f3f4'}
          />
        </View>

        <TouchableOpacity style={styles.logoutButton} onPress={handleLogout}>
          <Text style={styles.logoutButtonText}>Déconnexion</Text>
        </TouchableOpacity>

        <View style={styles.versionContainer}>
          <Text style={styles.versionText}>Osiris Calendar v1.0.0</Text>
        </View>
      </ScrollView>
    </View>
  );
}
```

## 5. FICHIER: app/(tabs)/files.tsx
### Action: REMPLACER complètement le contenu existant

```typescript
import React, { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  ScrollView, 
  TouchableOpacity, 
  useColorScheme,
  Alert,
  ActivityIndicator,
  Platform
} from 'react-native';
import Colors from '@/constants/Colors';
import { FileText, FolderOpen, Upload, Book, Lightbulb, FileQuestion, ChevronRight, FileImage, FilePen as FilePdf, Trash2, Check } from 'lucide-react-native';
import * as DocumentPicker from 'expo-document-picker';
import { createClient } from '@supabase/supabase-js';

// Initialize Supabase client
const supabase = createClient(
  process.env.EXPO_PUBLIC_SUPABASE_URL!,
  process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY!
);

interface File {
  id: string;
  name: string;
  size: number;
  type: string;
  subject: string;
  lastModified: Date;
  url: string;
}

interface Subject {
  id: string;
  name: string;
  color: string;
  icon: JSX.Element;
  fileCount: number;
}

export default function FilesScreen() {
  const colorScheme = useColorScheme();
  const colors = Colors[colorScheme ?? 'light'];
  const [activeTab, setActiveTab] = useState('files');
  const [files, setFiles] = useState<File[]>([]);
  const [subjects, setSubjects] = useState<Subject[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [selectedFiles, setSelectedFiles] = useState<string[]>([]);
  const [isEditMode, setIsEditMode] = useState(false);

  // Initialize subjects
  useEffect(() => {
    const defaultSubjects: Subject[] = [
      { 
        id: '1', 
        name: 'Mathematics', 
        color: '#6200EA', 
        icon: <Book size={24} color="#6200EA" />,
        fileCount: 0
      },
      { 
        id: '2', 
        name: 'Physics', 
        color: '#00BFA5', 
        icon: <Lightbulb size={24} color="#00BFA5" />,
        fileCount: 0
      },
      { 
        id: '3', 
        name: 'Biology', 
        color: '#FF5722', 
        icon: <FileQuestion size={24} color="#FF5722" />,
        fileCount: 0
      },
      { 
        id: '4', 
        name: 'Chemistry', 
        color: '#2196F3', 
        icon: <FileText size={24} color="#2196F3" />,
        fileCount: 0
      },
      { 
        id: '5', 
        name: 'History', 
        color: '#FF9800', 
        icon: <FolderOpen size={24} color="#FF9800" />,
        fileCount: 0
      },
    ];
    setSubjects(defaultSubjects);
  }, []);

  // Load files from Supabase
  useEffect(() => {
    loadFiles();
  }, []);

  const loadFiles = async () => {
    try {
      setIsLoading(true);
      
      // For demo purposes, we'll use mock data since Supabase might not be configured
      const mockFiles: File[] = [
        {
          id: '1',
          name: 'Calculus_Notes.pdf',
          size: 2048576, // 2MB
          type: 'application/pdf',
          subject: 'Mathematics',
          lastModified: new Date('2024-01-15'),
          url: 'https://example.com/file1.pdf'
        },
        {
          id: '2',
          name: 'Physics_Lab_Report.docx',
          size: 1024000, // 1MB
          type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
          subject: 'Physics',
          lastModified: new Date('2024-01-10'),
          url: 'https://example.com/file2.docx'
        },
        {
          id: '3',
          name: 'Biology_Diagram.png',
          size: 512000, // 512KB
          type: 'image/png',
          subject: 'Biology',
          lastModified: new Date('2024-01-08'),
          url: 'https://example.com/file3.png'
        }
      ];

      setFiles(mockFiles);

      // Update subject file counts
      setSubjects(prev => prev.map(subject => ({
        ...subject,
        fileCount: mockFiles.filter(file => file.subject === subject.name).length
      })));

    } catch (error) {
      console.error('Error loading files:', error);
      Alert.alert('Erreur', 'Impossible de charger les fichiers');
    } finally {
      setIsLoading(false);
    }
  };

  const handleFileUpload = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: '*/*',
        multiple: true,
        copyToCacheDirectory: true
      });

      if (!result.canceled && result.assets.length > 0) {
        setIsLoading(true);

        // For demo purposes, we'll simulate file upload
        const newFiles: File[] = result.assets.map(asset => ({
          id: Date.now().toString() + Math.random().toString(),
          name: asset.name,
          size: asset.size || 0,
          type: asset.mimeType || 'application/octet-stream',
          subject: 'Mathematics', // Default subject
          lastModified: new Date(),
          url: asset.uri
        }));

        setFiles(prev => [...prev, ...newFiles]);

        // Update subject file counts
        setSubjects(prev => prev.map(subject => ({
          ...subject,
          fileCount: [...files, ...newFiles].filter(file => file.subject === subject.name).length
        })));

        Alert.alert('Succès', `${newFiles.length} fichier(s) ajouté(s) avec succès`);
      }
    } catch (error) {
      console.error('Error uploading files:', error);
      Alert.alert('Erreur', 'Impossible d\'ajouter les fichiers');
    } finally {
      setIsLoading(false);
    }
  };

  const handleFileDelete = async () => {
    if (selectedFiles.length === 0) return;

    Alert.alert(
      'Confirmer la suppression',
      `Êtes-vous sûr de vouloir supprimer ${selectedFiles.length} fichier(s) ?`,
      [
        { text: 'Annuler', style: 'cancel' },
        {
          text: 'Supprimer',
          style: 'destructive',
          onPress: async () => {
            try {
              setIsLoading(true);

              // Remove files from state
              const updatedFiles = files.filter(file => !selectedFiles.includes(file.id));
              setFiles(updatedFiles);

              // Update subject file counts
              setSubjects(prev => prev.map(subject => ({
                ...subject,
                fileCount: updatedFiles.filter(file => file.subject === subject.name).length
              })));

              // Reset selection
              setSelectedFiles([]);
              setIsEditMode(false);
              
              Alert.alert('Succès', 'Fichiers supprimés avec succès');
            } catch (error) {
              console.error('Error deleting files:', error);
              Alert.alert('Erreur', 'Impossible de supprimer les fichiers');
            } finally {
              setIsLoading(false);
            }
          }
        }
      ]
    );
  };

  const handleFileSelect = (fileId: string) => {
    if (isEditMode) {
      setSelectedFiles(prev => 
        prev.includes(fileId)
          ? prev.filter(id => id !== fileId)
          : [...prev, fileId]
      );
    } else {
      // Handle file opening/preview
      const file = files.find(f => f.id === fileId);
      if (file) {
        if (Platform.OS === 'web') {
          // For web, try to open in new tab
          window.open(file.url, '_blank');
        } else {
          // For mobile, you could implement a file viewer
          Alert.alert('Fichier', `Ouverture de ${file.name}`);
        }
      }
    }
  };

  const handleSubjectSelect = (subject: Subject) => {
    // Filter files by subject or navigate to subject detail
    Alert.alert('Matière', `Affichage des fichiers pour ${subject.name} (${subject.fileCount} fichiers)`);
  };

  const getFileIcon = (fileType: string) => {
    if (fileType.startsWith('image/')) {
      return <FileImage size={24} color="#4CAF50" />;
    }
    if (fileType.includes('pdf')) {
      return <FilePdf size={24} color="#FF5722" />;
    }
    return <FileText size={24} color="#2196F3" />;
  };

  const formatFileSize = (bytes: number) => {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`;
  };

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: colors.background,
    },
    header: {
      paddingTop: 60,
      paddingHorizontal: 16,
      paddingBottom: 16,
      backgroundColor: colors.primary,
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-end',
    },
    headerLeft: {
      flex: 1,
    },
    headerTitle: {
      color: 'white',
      fontSize: 28,
      fontFamily: 'Inter-Bold',
    },
    headerSubtitle: {
      color: 'white',
      fontSize: 16,
      fontFamily: 'Inter-Regular',
      opacity: 0.9,
      marginTop: 4,
    },
    editButton: {
      paddingHorizontal: 16,
      paddingVertical: 8,
      backgroundColor: 'rgba(255, 255, 255, 0.2)',
      borderRadius: 8,
    },
    editButtonText: {
      color: 'white',
      fontFamily: 'Inter-Medium',
      fontSize: 14,
    },
    contentContainer: {
      flex: 1,
      padding: 16,
    },
    tabContainer: {
      flexDirection: 'row',
      marginBottom: 16,
      borderRadius: 8,
      backgroundColor: colors.cardBackground,
      overflow: 'hidden',
    },
    tabButton: {
      flex: 1,
      paddingVertical: 12,
      alignItems: 'center',
    },
    tabButtonActive: {
      backgroundColor: colors.primary,
    },
    tabButtonText: {
      fontFamily: 'Inter-Medium',
      fontSize: 14,
      color: colors.text,
    },
    tabButtonTextActive: {
      color: 'white',
    },
    uploadButton: {
      backgroundColor: colors.cardBackground,
      borderRadius: 8,
      borderWidth: 2,
      borderColor: colors.border,
      borderStyle: 'dashed',
      padding: 24,
      alignItems: 'center',
      justifyContent: 'center',
      marginBottom: 24,
    },
    uploadButtonText: {
      fontFamily: 'Inter-Medium',
      fontSize: 16,
      color: colors.primary,
      marginTop: 8,
    },
    fileCard: {
      flexDirection: 'row',
      alignItems: 'center',
      backgroundColor: colors.cardBackground,
      borderRadius: 8,
      padding: 16,
      marginBottom: 12,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.1,
      shadowRadius: 2,
      elevation: 2,
    },
    fileCheckbox: {
      width: 24,
      height: 24,
      borderRadius: 4,
      borderWidth: 2,
      borderColor: colors.primary,
      marginRight: 12,
      justifyContent: 'center',
      alignItems: 'center',
    },
    fileCheckboxSelected: {
      backgroundColor: colors.primary,
    },
    fileIcon: {
      marginRight: 16,
    },
    fileInfo: {
      flex: 1,
    },
    fileName: {
      fontFamily: 'Inter-Medium',
      fontSize: 16,
      color: colors.text,
    },
    fileDetails: {
      flexDirection: 'row',
      marginTop: 4,
    },
    fileDate: {
      fontFamily: 'Inter-Regular',
      fontSize: 12,
      color: colors.tabIconDefault,
    },
    fileSize: {
      fontFamily: 'Inter-Regular',
      fontSize: 12,
      color: colors.tabIconDefault,
      marginLeft: 8,
    },
    fileSubject: {
      fontFamily: 'Inter-Regular',
      fontSize: 12,
      color: colors.primary,
      marginLeft: 8,
    },
    subjectCard: {
      flexDirection: 'row',
      alignItems: 'center',
      backgroundColor: colors.cardBackground,
      borderRadius: 8,
      padding: 16,
      marginBottom: 12,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.1,
      shadowRadius: 2,
      elevation: 2,
    },
    subjectIcon: {
      width: 40,
      height: 40,
      borderRadius: 20,
      backgroundColor: colors.cardBackground,
      justifyContent: 'center',
      alignItems: 'center',
      marginRight: 16,
    },
    subjectInfo: {
      flex: 1,
    },
    subjectName: {
      fontFamily: 'Inter-Medium',
      fontSize: 16,
      color: colors.text,
    },
    subjectCount: {
      fontFamily: 'Inter-Regular',
      fontSize: 12,
      color: colors.tabIconDefault,
      marginTop: 4,
    },
    deleteButton: {
      position: 'absolute',
      bottom: 16,
      left: 16,
      right: 16,
      backgroundColor: colors.error,
      padding: 16,
      borderRadius: 8,
      alignItems: 'center',
      flexDirection: 'row',
      justifyContent: 'center',
    },
    deleteButtonText: {
      color: 'white',
      fontFamily: 'Inter-Bold',
      fontSize: 16,
      marginLeft: 8,
    },
    loadingContainer: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      justifyContent: 'center',
      alignItems: 'center',
    },
    emptyState: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      paddingVertical: 40,
    },
    emptyStateText: {
      fontFamily: 'Inter-Regular',
      fontSize: 16,
      color: colors.tabIconDefault,
      textAlign: 'center',
      marginTop: 16,
    },
  });

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <View style={styles.headerLeft}>
          <Text style={styles.headerTitle}>Fichiers & Révision</Text>
          <Text style={styles.headerSubtitle}>Matériel d'étude et ressources</Text>
        </View>
        {activeTab === 'files' && (
          <TouchableOpacity 
            style={styles.editButton}
            onPress={() => setIsEditMode(!isEditMode)}
          >
            <Text style={styles.editButtonText}>
              {isEditMode ? 'Terminé' : 'Modifier'}
            </Text>
          </TouchableOpacity>
        )}
      </View>

      <ScrollView style={styles.contentContainer}>
        <View style={styles.tabContainer}>
          <TouchableOpacity
            style={[styles.tabButton, activeTab === 'files' && styles.tabButtonActive]}
            onPress={() => setActiveTab('files')}
          >
            <Text 
              style={[
                styles.tabButtonText,
                activeTab === 'files' && styles.tabButtonTextActive
              ]}
            >
              Fichiers
            </Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={[styles.tabButton, activeTab === 'subjects' && styles.tabButtonActive]}
            onPress={() => setActiveTab('subjects')}
          >
            <Text 
              style={[
                styles.tabButtonText,
                activeTab === 'subjects' && styles.tabButtonTextActive
              ]}
            >
              Matières
            </Text>
          </TouchableOpacity>
        </View>

        {activeTab === 'files' ? (
          <>
            <TouchableOpacity 
              style={styles.uploadButton}
              onPress={handleFileUpload}
              disabled={isLoading}
            >
              <Upload size={32} color={colors.primary} />
              <Text style={styles.uploadButtonText}>Ajouter des fichiers</Text>
            </TouchableOpacity>

            {files.length === 0 ? (
              <View style={styles.emptyState}>
                <FileText size={48} color={colors.tabIconDefault} />
                <Text style={styles.emptyStateText}>
                  Aucun fichier ajouté.{'\n'}Appuyez sur "Ajouter des fichiers" pour commencer.
                </Text>
              </View>
            ) : (
              files.map(file => (
                <TouchableOpacity
                  key={file.id}
                  style={styles.fileCard}
                  onPress={() => handleFileSelect(file.id)}
                >
                  {isEditMode && (
                    <View style={[
                      styles.fileCheckbox,
                      selectedFiles.includes(file.id) && styles.fileCheckboxSelected
                    ]}>
                      {selectedFiles.includes(file.id) && (
                        <Check size={16} color="white" />
                      )}
                    </View>
                  )}
                  <View style={styles.fileIcon}>
                    {getFileIcon(file.type)}
                  </View>
                  <View style={styles.fileInfo}>
                    <Text style={styles.fileName}>{file.name}</Text>
                    <View style={styles.fileDetails}>
                      <Text style={styles.fileDate}>
                        {file.lastModified.toLocaleDateString()}
                      </Text>
                      <Text style={styles.fileSize}>
                        {formatFileSize(file.size)}
                      </Text>
                      <Text style={styles.fileSubject}>{file.subject}</Text>
                    </View>
                  </View>
                  {!isEditMode && <ChevronRight size={20} color={colors.tabIconDefault} />}
                </TouchableOpacity>
              ))
            )}
          </>
        ) : (
          <>
            {subjects.map(subject => (
              <TouchableOpacity 
                key={subject.id} 
                style={styles.subjectCard}
                onPress={() => handleSubjectSelect(subject)}
              >
                <View style={styles.subjectIcon}>
                  {subject.icon}
                </View>
                <View style={styles.subjectInfo}>
                  <Text style={styles.subjectName}>{subject.name}</Text>
                  <Text style={styles.subjectCount}>{subject.fileCount} fichiers</Text>
                </View>
                <ChevronRight size={20} color={colors.tabIconDefault} />
              </TouchableOpacity>
            ))}
          </>
        )}

        {isEditMode && selectedFiles.length > 0 && (
          <TouchableOpacity 
            style={styles.deleteButton}
            onPress={handleFileDelete}
          >
            <Trash2 size={20} color="white" />
            <Text style={styles.deleteButtonText}>
              Supprimer ({selectedFiles.length})
            </Text>
          </TouchableOpacity>
        )}
      </ScrollView>

      {isLoading && (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={colors.primary} />
        </View>
      )}
    </View>
  );
}
```

## 6. MODIFICATIONS DANS LE PACKAGE.JSON
### Action: AJOUTER ces dépendances si elles ne sont pas déjà présentes

```json
{
  "dependencies": {
    "@react-native-async-storage/async-storage": "^2.1.0",
    // ... autres dépendances existantes
  }
}
```

## RÉSUMÉ DES MODIFICATIONS

1. **utils/storage.ts** : Nouveau fichier pour la gestion de la sauvegarde locale avec AsyncStorage
2. **supabase/migrations/create_files_table.sql** : Migration pour la base de données des fichiers
3. **app/(tabs)/ai.tsx** : Correction du bug des styles + ajout de la sauvegarde des conversations
4. **app/(tabs)/settings.tsx** : Fonctionnalités réelles pour tous les paramètres avec sauvegarde
5. **app/(tabs)/files.tsx** : Fonctionnalités réelles pour la gestion des fichiers
6. **package.json** : Ajout d'AsyncStorage pour la sauvegarde locale

## INSTRUCTIONS D'INSTALLATION

1. Copiez le contenu de chaque fichier dans les emplacements correspondants
2. Installez AsyncStorage si ce n'est pas déjà fait : `npm install @react-native-async-storage/async-storage`
3. Si vous utilisez Supabase, exécutez la migration SQL dans votre base de données
4. Redémarrez l'application

Toutes les fonctionnalités sont maintenant pleinement opérationnelles avec sauvegarde persistante !